const _astro_dataLayerContent = [["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.3.0","content-config-digest","8d1b7566f4d3c391","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://oscarbustos.dev\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"always\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":false,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"prefetch\":{\"prefetchAll\":true,\"defaultStrategy\":\"hover\"},\"image\":{\"endpoint\":{\"route\":\"/_image/\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[\"oscarbustos.dev\"],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,22,23,31,32,40,41,49,50,58,59,67,68,76,77,85,86,94,95,103,104,113,114,122,123,131,132,140,141,149,150,158,159],"git-stash-explained",{id:11,data:13,body:18,filePath:19,digest:20,deferredRender:21},{title:14,description:15,pubDate:16,heroImage:17},"Git Stash: A Safe Place for Your Work in Progress","Learn how to temporarily store your changes with Git stash and why it can save you in tricky situations",["Date","2025-01-28T23:00:00.000Z"],"","As a developer, I often find myself in situations where I'm working on some changes but suddenly need to switch context - maybe to fix a critical bug on another branch or help a teammate with their code. This is where Git stash becomes my best friend.\n\n# What is Git Stash?\n\nGit stash is like a drawer where you can temporarily store your work in progress without committing it. It's separate from your working directory, staging area, and repository. Think of it as a safe place where your changes won't get lost when you need to switch contexts.\n\n# When Do I Use Git Stash?\n\nThe most common scenario where I use stash is when I need to switch branches but have uncommitted changes. Instead of creating a messy commit or losing my work, I can simply stash my changes, switch branches, and later retrieve them when I'm ready.\n\n# Basic Stash Commands I Use Daily\n\nLet's go through the commands I use most frequently:\n\n## Saving Changes\n\nTo store changes in the stash, I use:\n\n```bash\ngit stash save \"optional message\"\n```\n\nI always try to add a descriptive message - it has saved me countless times when trying to remember what I was working on.\n\n## Viewing Stashed Changes\n\nTo see what I have stored, I use:\n\n```bash\ngit stash list\n```\n\nThis shows me all my stashed changes in the format `stash@{0}: BRANCH: MESSAGE`. The number in curly braces is the stash index - think of it as an ID for each set of changes.\n\nIf I need to see the actual changes in a stash, I use:\n\n```bash\ngit stash show -p stash@{0}\n```\n\nThe `-p` flag gives me a detailed view of the changes, which is particularly helpful when I have multiple stashes and need to find the right one.\n\n## Retrieving Changes\n\nWhen I want to get my changes back, I have two options:\n\n```bash\ngit stash apply stash@{0}  # Applies changes and keeps them in stash\ngit stash pop stash@{0}    # Applies changes and removes them from stash\n```\n\nI typically use `pop` when I'm sure I won't need those changes again, and `apply` when I might need to apply the same changes multiple times.\n\n## Cleaning Up\n\nTo keep my stash organized, I occasionally need to remove old stashes:\n\n```bash\ngit stash drop stash@{0}  # Removes a specific stash\ngit stash clear          # Removes all stashes\n```\n\n# Important Things to Remember\n\nThrough my experience with Git stash, I've learned a few important lessons:\n\n1. Stash only works with tracked files. If you've created new files, make sure to add them to Git first.\n2. Stashes are available across all branches in your repository.\n3. You might encounter conflicts when applying stashed changes - resolve them just like you would resolve merge conflicts.\n\nGit stash has become an essential tool in my daily workflow. It gives me the flexibility to quickly switch between tasks without losing work or creating unnecessary commits. While it might seem like a simple feature, knowing how to use it effectively can make a big difference in your development workflow.\n\nWhat git stash commands do you use most often? Let me know in the comments below!","src/content/blog/git-stash-explained.mdx","bae6cfd2f7416a58",true,"bridge-remote-teams-ai",{id:22,data:24,body:28,filePath:29,digest:30,deferredRender:21},{title:25,description:26,pubDate:27,heroImage:17},"Bridge: Strengthening Remote Teams with AI","How a simple AI tool can enhance communication and connection in distributed teams",["Date","2025-01-25T23:00:00.000Z"],"After years leading remote teams, I've learned that success isn't just about technical tools - it's about fostering genuine human connections. This insight led me to develop Bridge, an application that uses AI to strengthen bonds in distributed teams.\n\n## The Distance Challenge\n\nRemote work is here to stay, but maintaining cohesive teams across distances remains challenging. Spontaneous office conversations have disappeared, and video calls tend to focus solely on work tasks.\n\n## The Solution: Automated Meaningful Conversations \n\nBridge uses AI to generate personalized icebreakers based on:\n- Team size\n- Professional roles\n- Personal interests\n- Current group dynamics\n\nQuestions integrate seamlessly with Slack or other communication platforms, enabling natural conversations in the team's usual channels.\n\n## Technology with Purpose\n\nTo quickly validate this solution, I chose:\n- React 19 for frontend, leveraging Server Components\n- Supabase as serverless backend\n- Feedback system to improve AI suggestions\n\n## Tangible Results\n\nIn my experience leading teams, these planned yet natural interactions have improved:\n- Cross-departmental communication\n- Sense of belonging\n- Collaborative project productivity\n\n## Next Steps\n\nBridge is under development as an MVP. If you lead a remote team and are interested in testing it, [contact me](#) for early access.\n\nThe code will be available on GitHub soon, building in public to receive community feedback.","src/content/blog/bridge-remote-teams-ai.mdx","aa05ac47dbbd8f0e","react-closures-traps",{id:31,data:33,body:37,filePath:38,digest:39,deferredRender:21},{title:34,description:35,pubDate:36,heroImage:17},"React Closures: Common Traps and How to Avoid Them","Understanding closures in React and preventing stale closure bugs in your applications",["Date","2024-11-21T23:00:00.000Z"],"JavaScript closures are a powerful feature, but they can lead to subtle bugs in React applications. Let's explore common closure traps and their solutions.\n\n## Understanding Closures in React\n\nA closure is formed when a function captures variables from its outer scope:\n\n```jsx\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  \n  // This function forms a closure over 'count'\n  const logCount = () => {\n    console.log(count);\n  };\n\n  return (\n    <button onClick={logCount}>\n      Log count: {count}\n    </button>\n  );\n};\n```\n\n## The Stale Closure Problem\n\n### Problem 1: useEffect Dependencies\n\n```jsx\nconst Timer = () => {\n  const [count, setCount] = useState(0);\n\n  // ❌ Stale closure: callback always sees initial count value\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(count + 1); // count is captured in closure\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []); // Missing dependency\n\n  // ✅ Solution: Use functional update\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(c => c + 1); // Always uses latest count\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n};\n```\n\n### Problem 2: Event Handlers\n\n```jsx\nconst SearchForm = () => {\n  const [query, setQuery] = useState('');\n  \n  // ❌ Stale closure in event handler\n  const handleSearch = useCallback(() => {\n    fetchResults(query);\n  }, []); // Missing dependency\n\n  // ✅ Solution: Include dependency\n  const handleSearch = useCallback(() => {\n    fetchResults(query);\n  }, [query]);\n\n  return <input onChange={e => setQuery(e.target.value)} />;\n};\n```\n\n## Using Refs to Escape Closure Traps\n\nWhen you need the latest value but don't want to trigger re-renders:\n\n```jsx\nconst LatestValueComponent = () => {\n  const [value, setValue] = useState('');\n  const valueRef = useRef(value);\n\n  // Keep ref updated with latest value\n  useEffect(() => {\n    valueRef.current = value;\n  }, [value]);\n\n  const handleClick = useCallback(() => {\n    // Always access latest value without dependency\n    console.log(valueRef.current);\n  }, []); // No dependencies needed\n\n  return (\n    <input \n      value={value}\n      onChange={e => setValue(e.target.value)}\n      onClick={handleClick}\n    />\n  );\n};\n```\n\n## Real World Example: Debounced Search\n\n```jsx\nconst SearchComponent = () => {\n  const [query, setQuery] = useState('');\n  const queryRef = useRef(query);\n\n  useEffect(() => {\n    queryRef.current = query;\n  }, [query]);\n\n  const debouncedSearch = useMemo(() => {\n    return debounce(async () => {\n      // Always uses latest query value\n      const results = await fetchResults(queryRef.current);\n      console.log(results);\n    }, 500);\n  }, []); // Empty deps - debounce function never changes\n\n  return (\n    <input\n      value={query}\n      onChange={e => {\n        setQuery(e.target.value);\n        debouncedSearch();\n      }}\n    />\n  );\n};\n```\n\n## Event Listeners and Cleanup\n\n```jsx\nconst EventListener = () => {\n  const [data, setData] = useState(null);\n  const dataRef = useRef(data);\n\n  useEffect(() => {\n    dataRef.current = data;\n  }, [data]);\n\n  useEffect(() => {\n    const handler = (event) => {\n      // Always access latest data\n      console.log(dataRef.current);\n    };\n\n    window.addEventListener('scroll', handler);\n    return () => window.removeEventListener('scroll', handler);\n  }, []); // No dependencies needed\n\n  return <div>{data}</div>;\n};\n```\n\n## useCallback and Dependencies\n\n```jsx\nconst CallbackComponent = ({ onSubmit }) => {\n  const [value, setValue] = useState('');\n  \n  // ❌ Stale closure: callback uses old value\n  const handleSubmit = useCallback(() => {\n    onSubmit(value);\n  }, [onSubmit]); // Missing 'value' dependency\n\n  // ✅ Solution 1: Add all dependencies\n  const handleSubmit = useCallback(() => {\n    onSubmit(value);\n  }, [onSubmit, value]);\n\n  // ✅ Solution 2: Use ref if you need stable callback\n  const valueRef = useRef(value);\n  useEffect(() => {\n    valueRef.current = value;\n  }, [value]);\n\n  const handleSubmit = useCallback(() => {\n    onSubmit(valueRef.current);\n  }, [onSubmit]);\n};\n```\n\n## Key Takeaways\n\n1. Always include dependencies in hooks unless you have a specific reason not to\n2. Use functional updates with setState to avoid closure problems\n3. Refs can help access latest values without triggering re-renders\n4. Be careful with useCallback dependencies and closures\n5. Watch out for stale closures in event listeners and timeouts","src/content/blog/react-closures-traps.mdx","79669af823db0fbd","higher-order-components-2024",{id:40,data:42,body:46,filePath:47,digest:48,deferredRender:21},{title:43,description:44,pubDate:45,heroImage:17},"Higher-Order Components in 2024: Are They Still Relevant?","A practical examination of HOCs in modern React development and when they still make sense to use",["Date","2024-11-14T23:00:00.000Z"],"Higher-Order Components (HOCs) were once a primary pattern for code reuse in React. While hooks have largely replaced them, HOCs still have specific use cases where they excel.\n\n## What is a Higher-Order Component?\n\nAt its core, a HOC is just a function that takes a component and returns a new enhanced component:\n\n```jsx\nconst withData = (WrappedComponent) => {\n  return (props) => {\n    // Add new functionality here\n    return <WrappedComponent {...props} />;\n  };\n};\n```\n\n## Modern Use Cases for HOCs\n\n### 1. DOM Event Interception\n\nHOCs excel at intercepting and modifying DOM events:\n\n```jsx\nconst withClickOutside = (Component) => {\n  return (props) => {\n    const ref = useRef();\n\n    useEffect(() => {\n      const handleClick = (event) => {\n        if (ref.current && !ref.current.contains(event.target)) {\n          props.onClickOutside?.();\n        }\n      };\n\n      document.addEventListener('click', handleClick);\n      return () => document.removeEventListener('click', handleClick);\n    }, []);\n\n    return (\n      <div ref={ref}>\n        <Component {...props} />\n      </div>\n    );\n  };\n};\n\n// Usage\nconst Menu = withClickOutside(({ onClickOutside }) => {\n  return <div>Menu Content</div>;\n});\n```\n\n### 2. Analytics and Tracking\n\nHOCs provide a clean way to add analytics without cluttering components:\n\n```jsx\nconst withTracking = (Component, trackingName) => {\n  return (props) => {\n    useEffect(() => {\n      analytics.trackPageView(trackingName);\n    }, []);\n\n    const trackEvent = (eventName) => {\n      analytics.trackEvent(trackingName, eventName);\n    };\n\n    return <Component {...props} onTrack={trackEvent} />;\n  };\n};\n\n// Usage\nconst UserProfile = withTracking(({ onTrack }) => {\n  return (\n    <button onClick={() => onTrack('profile_updated')}>\n      Update Profile\n    </button>\n  );\n}, 'user_profile');\n```\n\n### 3. Context Selectors\n\nHOCs can optimize Context performance by preventing unnecessary re-renders:\n\n```jsx\nconst withTheme = (selector) => (WrappedComponent) => {\n  const MemoizedComponent = React.memo(WrappedComponent);\n  \n  return (props) => {\n    const theme = useContext(ThemeContext);\n    const selectedValue = selector(theme);\n    \n    return <MemoizedComponent {...props} theme={selectedValue} />;\n  };\n};\n\n// Usage\nconst Button = withTheme(\n  theme => ({ color: theme.primary })\n)(({ theme }) => {\n  return <button style={{ backgroundColor: theme.color }}>Click</button>;\n});\n```\n\n## When Not to Use HOCs\n\n### 1. Simple State Logic\n\n```jsx\n// ❌ Don't use HOC for this\nconst withCounter = (Component) => {\n  return (props) => {\n    const [count, setCount] = useState(0);\n    return (\n      <Component \n        {...props} \n        count={count} \n        increment={() => setCount(c => c + 1)} \n      />\n    );\n  };\n};\n\n// ✅ Use a hook instead\nconst useCounter = () => {\n  const [count, setCount] = useState(0);\n  return {\n    count,\n    increment: () => setCount(c => c + 1)\n  };\n};\n```\n\n### 2. Data Fetching\n\n```jsx\n// ❌ Don't use HOC for data fetching\nconst withUserData = (Component) => {\n  return (props) => {\n    const [user, setUser] = useState(null);\n    \n    useEffect(() => {\n      fetchUser().then(setUser);\n    }, []);\n    \n    return <Component {...props} user={user} />;\n  };\n};\n\n// ✅ Use a hook or data fetching library instead\nconst useUser = () => {\n  const [user, setUser] = useState(null);\n  useEffect(() => {\n    fetchUser().then(setUser);\n  }, []);\n  return user;\n};\n```\n\n## Modern HOC Implementation Tips\n\n### Use TypeScript for Better Type Safety\n\n```typescript\ntype WithLoadingProps = {\n  loading?: boolean;\n};\n\nfunction withLoading<T extends WithLoadingProps = WithLoadingProps>(\n  WrappedComponent: React.ComponentType<T>\n) {\n  return function WithLoadingComponent(\n    props: Omit<T, keyof WithLoadingProps> & WithLoadingProps\n  ) {\n    if (props.loading) {\n      return <div>Loading...</div>;\n    }\n    return <WrappedComponent {...(props as T)} />;\n  };\n}\n```\n\n### Compose Multiple HOCs\n\n```jsx\nconst compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x);\n\nconst enhance = compose(\n  withTheme,\n  withTracking('button'),\n  withClickOutside\n);\n\nconst EnhancedButton = enhance(Button);\n```\n\n## Key Takeaways\n\n1. HOCs are still useful for cross-cutting concerns like analytics and event handling\n2. Prefer hooks for state management and data fetching\n3. HOCs work well with TypeScript for type safety\n4. Consider HOCs when you need to wrap components with DOM manipulations\n5. Use composition utilities when combining multiple HOCs","src/content/blog/higher-order-components-2024.mdx","423ee6ce58e920c2","react-data-fetching-patterns",{id:49,data:51,body:55,filePath:56,digest:57,deferredRender:21},{title:52,description:53,pubDate:54,heroImage:17},"React Data Fetching Patterns: Performance and Best Practices","Learn the most effective patterns for fetching data in React applications while maintaining optimal performance",["Date","2024-11-28T23:00:00.000Z"],"Data fetching in React can significantly impact your application's performance. Let's explore the most effective patterns and common pitfalls to avoid.\n\n## Basic Data Fetching Pattern\n\nThe simplest approach using `useEffect`:\n\n```jsx\nconst UserProfile = ({ userId }) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(`/api/users/${userId}`);\n        const json = await response.json();\n        setData(json);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [userId]);\n\n  if (loading) return <Spinner />;\n  if (error) return <Error message={error.message} />;\n  if (!data) return null;\n\n  return <ProfileCard user={data} />;\n};\n```\n\n## Avoiding Request Waterfalls\n\nRequest waterfalls occur when fetches depend on each other:\n\n```jsx\n// ❌ Bad: Sequential requests\nconst Dashboard = () => {\n  const [user, setUser] = useState(null);\n  const [posts, setPosts] = useState(null);\n\n  useEffect(() => {\n    const fetchUser = async () => {\n      const userData = await fetch('/api/user');\n      setUser(userData);\n    };\n    fetchUser();\n  }, []);\n\n  useEffect(() => {\n    if (!user) return;\n    const fetchPosts = async () => {\n      const postsData = await fetch(`/api/posts/${user.id}`);\n      setPosts(postsData);\n    };\n    fetchPosts();\n  }, [user]);\n};\n\n// ✅ Good: Parallel requests\nconst Dashboard = () => {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const [userData, postsData] = await Promise.all([\n        fetch('/api/user'),\n        fetch('/api/posts')\n      ]);\n      setData({ user: userData, posts: postsData });\n    };\n    fetchData();\n  }, []);\n};\n```\n\n## Data Provider Pattern\n\nIsolate fetching logic and provide data to multiple components:\n\n```jsx\nconst DataContext = createContext();\n\nconst DataProvider = ({ children }) => {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      const result = await fetch('/api/data');\n      setData(result);\n    };\n    fetchData();\n  }, []);\n\n  return (\n    <DataContext.Provider value={data}>\n      {children}\n    </DataContext.Provider>\n  );\n};\n\n// Usage in components\nconst useData = () => useContext(DataContext);\n\nconst Component = () => {\n  const data = useData();\n  return <div>{data}</div>;\n};\n```\n\n## Custom Hook for Reusable Fetching\n\nCreate a reusable hook with loading, error, and data states:\n\n```jsx\nconst useFetch = (url, options = {}) => {\n  const [state, setState] = useState({\n    data: null,\n    loading: true,\n    error: null\n  });\n\n  useEffect(() => {\n    let mounted = true;\n\n    const fetchData = async () => {\n      try {\n        setState(prev => ({ ...prev, loading: true }));\n        const response = await fetch(url, options);\n        const data = await response.json();\n        \n        if (mounted) {\n          setState({ data, loading: false, error: null });\n        }\n      } catch (error) {\n        if (mounted) {\n          setState({ data: null, loading: false, error });\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      mounted = false;\n    };\n  }, [url]);\n\n  return state;\n};\n\n// Usage\nconst Component = () => {\n  const { data, loading, error } = useFetch('/api/data');\n  \n  if (loading) return <Spinner />;\n  if (error) return <Error message={error.message} />;\n  \n  return <div>{data}</div>;\n};\n```\n\n## Race Condition Prevention\n\nHandle multiple requests and prevent stale data:\n\n```jsx\nconst SearchResults = ({ query }) => {\n  const [results, setResults] = useState([]);\n  \n  useEffect(() => {\n    let currentQuery = true;\n    \n    const fetchResults = async () => {\n      try {\n        const response = await fetch(`/api/search?q=${query}`);\n        const data = await response.json();\n        \n        if (currentQuery) {\n          setResults(data);\n        }\n      } catch (error) {\n        if (currentQuery) {\n          console.error(error);\n        }\n      }\n    };\n    \n    fetchResults();\n    \n    return () => {\n      currentQuery = false;\n    };\n  }, [query]);\n  \n  return <ResultsList results={results} />;\n};\n```\n\n## Browser Limitations and Performance\n\nRemember browser request limits:\n\n```jsx\n// ❌ Bad: Too many parallel requests\nconst Dashboard = () => {\n  useEffect(() => {\n    // Browser might queue these requests\n    fetch('/api/users');\n    fetch('/api/posts');\n    fetch('/api/comments');\n    fetch('/api/notifications');\n    fetch('/api/messages');\n    fetch('/api/settings');\n  }, []);\n};\n\n// ✅ Good: Batch related requests\nconst Dashboard = () => {\n  useEffect(() => {\n    fetch('/api/dashboard-data');  // Single endpoint returns all needed data\n  }, []);\n};\n```\n\n## Key Takeaways\n\n1. Use parallel fetching when possible\n2. Implement proper error and loading states\n3. Prevent race conditions in search/filter scenarios\n4. Consider browser request limits\n5. Use data providers for shared data\n6. Create reusable fetch hooks for common patterns","src/content/blog/react-data-fetching-patterns.mdx","33891ae6aa472844","react-debounce-throttling",{id:58,data:60,body:64,filePath:65,digest:66,deferredRender:21},{title:61,description:62,pubDate:63,heroImage:17},"Implementing Debounce and Throttling in React: A Practical Guide","Learn how to implement debounce and throttling correctly in React with real-world examples",["Date","2024-12-05T23:00:00.000Z"],"## Creating a Reusable useDebounce Hook\n\nA practical implementation of a debounce hook for text inputs:\n\n```jsx\nconst useDebounce = (callback, delay) => {\n  const callbackRef = useRef(callback);\n  \n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n  \n  return useMemo(() => {\n    const debouncedFn = (...args) => {\n      if (debouncedFn.timeout) {\n        clearTimeout(debouncedFn.timeout);\n      }\n      \n      debouncedFn.timeout = setTimeout(() => {\n        callbackRef.current(...args);\n      }, delay);\n    };\n    \n    return debouncedFn;\n  }, [delay]);\n};\n\n// Usage for Search Input\nconst SearchComponent = () => {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  \n  const searchAPI = async (value) => {\n    const data = await fetch(`/api/search?q=${value}`);\n    setResults(await data.json());\n  };\n  \n  const debouncedSearch = useDebounce(searchAPI, 300);\n  \n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={query}\n        onChange={e => {\n          setQuery(e.target.value);\n          debouncedSearch(e.target.value);\n        }}\n      />\n      <SearchResults results={results} />\n    </div>\n  );\n};\n```\n\n## Implementing useThrottle for Scroll Events\n\nA throttle hook for handling scroll events:\n\n```jsx\nconst useThrottle = (callback, limit) => {\n  const callbackRef = useRef(callback);\n  const throttlingRef = useRef(false);\n  \n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n  \n  return useMemo(() => {\n    const throttledFn = (...args) => {\n      if (!throttlingRef.current) {\n        callbackRef.current(...args);\n        throttlingRef.current = true;\n        \n        setTimeout(() => {\n          throttlingRef.current = false;\n        }, limit);\n      }\n    };\n    \n    return throttledFn;\n  }, [limit]);\n};\n\n// Usage for Infinite Scroll\nconst InfiniteScroll = () => {\n  const [items, setItems] = useState([]);\n  const [page, setPage] = useState(1);\n  \n  const loadMore = async () => {\n    const data = await fetch(`/api/items?page=${page}`);\n    const newItems = await data.json();\n    setItems(prev => [...prev, ...newItems]);\n    setPage(p => p + 1);\n  };\n  \n  const handleScroll = (e) => {\n    const { scrollTop, clientHeight, scrollHeight } = e.target;\n    \n    if (scrollHeight - scrollTop <= clientHeight * 1.5) {\n      loadMore();\n    }\n  };\n  \n  const throttledScroll = useThrottle(handleScroll, 500);\n  \n  return (\n    <div onScroll={throttledScroll} style={{ height: '400px', overflow: 'auto' }}>\n      {items.map(item => (\n        <ItemCard key={item.id} {...item} />\n      ))}\n    </div>\n  );\n};\n```\n\n## Form Submission with Debounce\n\nPrevent multiple form submissions:\n\n```jsx\nconst DebouncedForm = () => {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: ''\n  });\n  \n  const submitForm = async (data) => {\n    await fetch('/api/submit', {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  };\n  \n  const debouncedSubmit = useDebounce(submitForm, 1000);\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    debouncedSubmit(formData);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={formData.name}\n        onChange={e => setFormData(prev => ({\n          ...prev,\n          name: e.target.value\n        }))}\n      />\n      <input\n        type=\"email\"\n        value={formData.email}\n        onChange={e => setFormData(prev => ({\n          ...prev,\n          email: e.target.value\n        }))}\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n## Window Resize with Throttle\n\nHandle window resize events efficiently:\n\n```jsx\nconst ResponsiveLayout = () => {\n  const [width, setWidth] = useState(window.innerWidth);\n  \n  const handleResize = () => {\n    setWidth(window.innerWidth);\n  };\n  \n  const throttledResize = useThrottle(handleResize, 200);\n  \n  useEffect(() => {\n    window.addEventListener('resize', throttledResize);\n    return () => window.removeEventListener('resize', throttledResize);\n  }, []);\n  \n  return (\n    <div>\n      {width > 768 ? (\n        <DesktopLayout />\n      ) : (\n        <MobileLayout />\n      )}\n    </div>\n  );\n};\n```\n\n## Cleanup and Memory Management\n\nAlways clean up timers to prevent memory leaks:\n\n```jsx\nconst useDebouncedEffect = (callback, deps, delay) => {\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      callback();\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [...deps, delay]);\n};\n\n// Usage\nconst AutoSaveComponent = () => {\n  const [content, setContent] = useState('');\n  \n  useDebouncedEffect(\n    () => {\n      saveToServer(content);\n    },\n    [content],\n    1000\n  );\n  \n  return (\n    <textarea\n      value={content}\n      onChange={e => setContent(e.target.value)}\n      placeholder=\"Auto-saves after 1 second of inactivity\"\n    />\n  );\n};\n```\n\n## Key Takeaways\n\n1. Use debounce for text inputs and form submissions\n2. Use throttle for scroll and resize events\n3. Always clean up timers in useEffect\n4. Use refs to keep callbacks up to date\n5. Consider performance impact when choosing delay times","src/content/blog/react-debounce-throttling.mdx","0f182d110673dc72","react-dom-patterns",{id:67,data:69,body:73,filePath:74,digest:75,deferredRender:21},{title:70,description:71,pubDate:72,heroImage:17},"Advanced DOM Handling Patterns in React","Learn advanced patterns for handling DOM operations effectively in React applications",["Date","2024-12-12T23:00:00.000Z"],"## Refs for Complex DOM Operations\n\n```jsx\nconst ScrollSync = () => {\n  const containerRef = useRef();\n  const contentRef = useRef();\n  \n  useLayoutEffect(() => {\n    const syncScroll = () => {\n      const { scrollTop, scrollHeight, clientHeight } = containerRef.current;\n      const progress = scrollTop / (scrollHeight - clientHeight);\n      \n      contentRef.current.style.transform = `translateY(-${progress * 100}%)`;\n    };\n    \n    const container = containerRef.current;\n    container.addEventListener('scroll', syncScroll);\n    return () => container.removeEventListener('scroll', syncScroll);\n  }, []);\n\n  return (\n    <div ref={containerRef} className=\"scroll-container\">\n      <div ref={contentRef} className=\"sync-content\">\n        {/* Content */}\n      </div>\n    </div>\n  );\n};\n```\n\n## DOM Measurements Hook\n\n```jsx\nconst useMeasure = () => {\n  const ref = useRef();\n  const [bounds, setBounds] = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  });\n\n  useLayoutEffect(() => {\n    const measure = () => {\n      setBounds(ref.current.getBoundingClientRect());\n    };\n\n    measure();\n    \n    const observer = new ResizeObserver(measure);\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  return [ref, bounds];\n};\n\n// Usage\nconst ResponsiveComponent = () => {\n  const [ref, bounds] = useMeasure();\n  \n  return (\n    <div ref={ref}>\n      Width: {bounds.width}px\n      Height: {bounds.height}px\n    </div>\n  );\n};\n```\n\n## IntersectionObserver Hook\n\n```jsx\nconst useIntersection = (options = {}) => {\n  const [isVisible, setIsVisible] = useState(false);\n  const elementRef = useRef();\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) => {\n      setIsVisible(entry.isIntersecting);\n    }, options);\n\n    if (elementRef.current) {\n      observer.observe(elementRef.current);\n    }\n\n    return () => {\n      if (elementRef.current) {\n        observer.unobserve(elementRef.current);\n      }\n    };\n  }, [options]);\n\n  return [elementRef, isVisible];\n};\n\n// Usage\nconst LazyImage = ({ src, alt }) => {\n  const [ref, isVisible] = useIntersection({ threshold: 0.1 });\n  \n  return (\n    <div ref={ref}>\n      {isVisible && <img src={src} alt={alt} />}\n    </div>\n  );\n};\n```\n\n## Focus Management\n\n```jsx\nconst useFocusTrap = () => {\n  const elementRef = useRef();\n\n  useEffect(() => {\n    const element = elementRef.current;\n    const focusableElements = element.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n    \n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n\n    const handleKeyDown = (e) => {\n      if (e.key === 'Tab') {\n        if (e.shiftKey) {\n          if (document.activeElement === firstElement) {\n            e.preventDefault();\n            lastElement.focus();\n          }\n        } else {\n          if (document.activeElement === lastElement) {\n            e.preventDefault();\n            firstElement.focus();\n          }\n        }\n      }\n    };\n\n    element.addEventListener('keydown', handleKeyDown);\n    firstElement.focus();\n\n    return () => {\n      element.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n\n  return elementRef;\n};\n\n// Usage\nconst Modal = () => {\n  const focusTrapRef = useFocusTrap();\n  \n  return (\n    <div ref={focusTrapRef}>\n      <button>First</button>\n      <input type=\"text\" />\n      <button>Last</button>\n    </div>\n  );\n};\n```\n\n## Custom ScrollTo Animation\n\n```jsx\nconst useScrollTo = () => {\n  const scrollTo = useCallback((element, options = {}) => {\n    const {\n      offset = 0,\n      duration = 1000,\n      easing = t => t\n    } = options;\n\n    const start = window.pageYOffset;\n    const target = element.getBoundingClientRect().top + start + offset;\n    const startTime = performance.now();\n    \n    const animate = currentTime => {\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      window.scrollTo(0, start + (target - start) * easing(progress));\n      \n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n\n    requestAnimationFrame(animate);\n  }, []);\n\n  return scrollTo;\n};\n\n// Usage\nconst ScrollableContent = () => {\n  const scrollTo = useScrollTo();\n  const targetRef = useRef();\n  \n  const handleClick = () => {\n    scrollTo(targetRef.current, {\n      offset: -20,\n      duration: 800\n    });\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>Scroll to element</button>\n      <div ref={targetRef}>Target Element</div>\n    </div>\n  );\n};\n```\n\n## Key Takeaways\n\n1. Use Refs for direct DOM manipulation\n2. Implement custom hooks for reusable DOM operations\n3. Handle cleanup properly in useEffect\n4. Use ResizeObserver for element measurements\n5. Manage focus for accessibility","src/content/blog/react-dom-patterns.mdx","2c9bb5bdaa98f58e","react-error-handling",{id:76,data:78,body:82,filePath:83,digest:84,deferredRender:21},{title:79,description:80,pubDate:81,heroImage:17},"Universal Error Handling in React: ErrorBoundary and Beyond","Implementing robust error handling in React applications using ErrorBoundaries and modern patterns",["Date","2024-12-19T23:00:00.000Z"],"## Basic ErrorBoundary Implementation\n\nA foundation for catching and handling React errors:\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false, error: null };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log to error reporting service\n    console.error('ErrorBoundary caught an error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || <DefaultErrorUI error={this.state.error} />;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage\nconst App = () => {\n  return (\n    <ErrorBoundary fallback={<CustomErrorPage />}>\n      <MainContent />\n    </ErrorBoundary>\n  );\n};\n```\n\n## Handling Async Errors\n\nCatch errors in async operations and propagate them to ErrorBoundary:\n\n```jsx\nconst useAsyncError = () => {\n  const [, setError] = useState();\n  return useCallback(\n    error => {\n      setError(() => {\n        throw error;\n      });\n    },\n    []\n  );\n};\n\nconst AsyncComponent = () => {\n  const throwError = useAsyncError();\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch('/api/data');\n        const data = await response.json();\n        // Use data...\n      } catch (error) {\n        throwError(error);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return <div>Loading...</div>;\n};\n```\n\n## Reusable Error Boundary Hook\n\nCreate a custom hook for error boundaries:\n\n```jsx\nconst useErrorBoundary = () => {\n  const [error, setError] = useState(null);\n\n  if (error) {\n    throw error;\n  }\n\n  return setError;\n};\n\nconst ComponentWithError = () => {\n  const throwError = useErrorBoundary();\n\n  const handleClick = () => {\n    try {\n      riskyOperation();\n    } catch (error) {\n      throwError(error);\n    }\n  };\n\n  return <button onClick={handleClick}>Trigger Error</button>;\n};\n```\n\n## Network Error Handling\n\nHandle API errors gracefully:\n\n```jsx\nconst useFetch = (url) => {\n  const [state, setState] = useState({\n    data: null,\n    error: null,\n    loading: true\n  });\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        setState({ data, error: null, loading: false });\n      } catch (error) {\n        setState({ data: null, error, loading: false });\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return state;\n};\n\nconst UserProfile = ({ userId }) => {\n  const { data, error, loading } = useFetch(`/api/users/${userId}`);\n\n  if (loading) return <LoadingSpinner />;\n  if (error) return <ErrorMessage error={error} />;\n\n  return <ProfileData user={data} />;\n};\n```\n\n## Form Error Handling\n\nHandle form validation and submission errors:\n\n```jsx\nconst FormWithErrorHandling = () => {\n  const [errors, setErrors] = useState({});\n  \n  const validate = (values) => {\n    const errors = {};\n    \n    if (!values.email) {\n      errors.email = 'Required';\n    } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i.test(values.email)) {\n      errors.email = 'Invalid email address';\n    }\n    \n    return errors;\n  };\n\n  const handleSubmit = async (values) => {\n    try {\n      const errors = validate(values);\n      \n      if (Object.keys(errors).length > 0) {\n        setErrors(errors);\n        return;\n      }\n\n      await submitForm(values);\n    } catch (error) {\n      setErrors({ submit: error.message });\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"email\" />\n      {errors.email && <span className=\"error\">{errors.email}</span>}\n      \n      {errors.submit && (\n        <div className=\"error-banner\">{errors.submit}</div>\n      )}\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n## Global Error Handler\n\nCatch unhandled errors application-wide:\n\n```jsx\nconst GlobalErrorHandler = () => {\n  useEffect(() => {\n    const handler = (event) => {\n      console.error(\n        'Unhandled error:',\n        event.error?.message || 'Unknown error'\n      );\n      \n      // Prevent default browser error overlay\n      event.preventDefault();\n      \n      // Show user-friendly error message\n      // You could use a global state management solution here\n      showErrorNotification(\n        'Something went wrong. Please try again later.'\n      );\n    };\n\n    window.addEventListener('error', handler);\n    window.addEventListener('unhandledrejection', handler);\n\n    return () => {\n      window.removeEventListener('error', handler);\n      window.removeEventListener('unhandledrejection', handler);\n    };\n  }, []);\n\n  return null;\n};\n\n// Usage in root component\nconst App = () => (\n  <>\n    <GlobalErrorHandler />\n    <RestOfApp />\n  </>\n);\n```\n\n## Key Error Handling Strategies\n\n1. Use ErrorBoundary for component rendering errors\n2. Implement async error handling with custom hooks\n3. Handle network errors in data fetching operations\n4. Validate forms and handle submission errors gracefully\n5. Set up global error handling for unhandled exceptions","src/content/blog/react-error-handling.mdx","5df1574f48bba083","react-memoization-guide",{id:85,data:87,body:91,filePath:92,digest:93,deferredRender:21},{title:88,description:89,pubDate:90,heroImage:17},"React Memoization: When and How to Use useMemo, useCallback and React.memo","A practical guide to understanding memoization in React and avoiding common pitfalls",["Date","2024-12-26T23:00:00.000Z"],"Memoization in React is often misused, leading to more complexity without actual performance benefits. Let's understand when it's truly needed and how to use it effectively.\n\n## What Problem Does Memoization Solve?\n\nThe core issue memoization addresses is referential equality in JavaScript:\n\n```jsx\nconst a = { id: 1 };\nconst b = { id: 1 };\n\nconsole.log(a === b); // false\nconsole.log({ id: 1 } === { id: 1 }); // false\n```\n\nThis becomes important in React when comparing values between re-renders or in dependency arrays.\n\n## useMemo: Preserving Object References\n\n```jsx\n// ❌ Bad: New object created every render\nconst Component = () => {\n  const config = { theme: 'dark', size: 'large' };\n  \n  return <Child config={config} />;\n}\n\n// ✅ Good: Object reference preserved between renders\nconst Component = () => {\n  const config = useMemo(() => ({ \n    theme: 'dark', \n    size: 'large' \n  }), []);\n  \n  return <Child config={config} />;\n}\n```\n\n## useCallback: Function Memoization\n\nCommon mistake: using useCallback unnecessarily.\n\n```jsx\n// ❌ Unnecessary: Button doesn't use React.memo\nconst Component = () => {\n  const handleClick = useCallback(() => {\n    console.log('clicked');\n  }, []);\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n\n// ✅ Necessary: When used in dependency arrays\nconst Component = () => {\n  const [count, setCount] = useState(0);\n  \n  const increment = useCallback(() => {\n    setCount(c => c + 1);\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener('keypress', increment);\n    return () => document.removeEventListener('keypress', increment);\n  }, [increment]); // Used in dependencies\n\n  return <button onClick={increment}>Count: {count}</button>;\n}\n```\n\n## React.memo: Component Memoization\n\nThe most powerful but also most dangerous memoization tool:\n\n```jsx\n// ✅ Good use case: Pure, presentational component\nconst ExpensiveChart = React.memo(({ data, config }) => {\n  // Complex chart rendering\n  return <div>{/* Chart */}</div>;\n});\n\n// ❌ Bad use case: Component with children\nconst Layout = React.memo(({ children }) => {\n  return <div>{children}</div>;\n});\n```\n\n## Common Pitfalls\n\n### 1. Breaking Memoization with Inline Objects\n\n```jsx\n// ❌ Bad: Memoization broken by inline styles\nconst Component = () => {\n  return (\n    <MemoizedChild \n      style={{ margin: 20 }} // New object every render\n    />\n  );\n}\n\n// ✅ Good: Move object outside or use useMemo\nconst Component = () => {\n  const style = useMemo(() => ({ margin: 20 }), []);\n  return <MemoizedChild style={style} />;\n}\n```\n\n### 2. Missing Dependencies\n\n```jsx\n// ❌ Bad: Missing dependency\nconst Component = ({ data }) => {\n  const processData = useCallback(() => {\n    return data.map(item => item.value);\n  }, []); // data should be in deps array\n\n  return <Child onProcess={processData} />;\n}\n\n// ✅ Good: Include all dependencies\nconst Component = ({ data }) => {\n  const processData = useCallback(() => {\n    return data.map(item => item.value);\n  }, [data]);\n\n  return <Child onProcess={processData} />;\n}\n```\n\n## Real World Example: Search Component\n\n```jsx\nconst SearchComponent = ({ onSearch }) => {\n  // Memoize options object\n  const options = useMemo(() => ({\n    debounceTime: 300,\n    minLength: 3,\n    maxResults: 10\n  }), []);\n\n  // Memoize search handler for useEffect dependency\n  const handleSearch = useCallback((term) => {\n    if (term.length >= options.minLength) {\n      onSearch(term);\n    }\n  }, [onSearch, options.minLength]);\n\n  // Effect depends on memoized value\n  useEffect(() => {\n    const timer = setTimeout(handleSearch, options.debounceTime);\n    return () => clearTimeout(timer);\n  }, [handleSearch, options.debounceTime]);\n\n  return <input onChange={e => handleSearch(e.target.value)} />;\n}\n\n// Only use React.memo if parent re-renders frequently\nexport default React.memo(SearchComponent);\n```\n\n## When NOT to Use Memoization\n\n1. For simple primitive props\n2. Components that always need to re-render\n3. When the cost of comparison exceeds re-render cost\n4. Components with frequently changing dependencies\n\n## Key Takeaways\n\n1. Use useCallback when function is dependency in hooks\n2. Use useMemo for complex objects used in deps or memo'd components\n3. Use React.memo sparingly and only for pure components\n4. Profile performance before adding memoization","src/content/blog/react-memoization-guide.mdx","d6a03a72a4f8e8ed","common-react-mistakes",{id:94,data:96,body:100,filePath:101,digest:102,deferredRender:21},{title:97,description:98,pubDate:99,heroImage:17},"5 Common Mistakes When Starting with React (And How to Avoid Them)","Learn about the most frequent mistakes we make when starting with React and discover current best practices for developing modern applications",["Date","2025-01-30T23:00:00.000Z"],"When starting with a new technology, especially with a powerful framework like React, making mistakes is part of the learning process. Even with React's comprehensive documentation, there are certain practices we only learn through experience.\n\nToday, I want to share the 5 most common mistakes we tend to make when starting with React and, more importantly, how to avoid them using current best practices.\n\n## 1. Using Create React App (CRA)\n\nFor a long time, Create React App was the default tool for starting React projects. Its \"zero-configuration\" promise made it very attractive for beginners. However, today we have better alternatives.\n\n**The modern solution**: Using Vite + SWC\n\n```bash\nnpm create vite\n# Select React and JavaScript/TypeScript + SWC\ncd my-project\nnpm i && npm run dev\n```\n\nVite offers a much faster development experience and more flexible configuration than CRA. Additionally, using SWC (Speedy Web Compiler) instead of Babel, we get significantly faster code transformations.\n\n## 2. Using defaultProps\n\nAlthough `defaultProps` was the standard way to handle default prop values for a long time, we now have a more elegant solution using modern JavaScript features.\n\n**❌ Old way:**\n```jsx\nfunction Card(props) {\n  return <div>{props.title}</div>\n}\n\nCard.defaultProps = {\n  title: 'Default title'\n}\n```\n\n**✅ Modern way:**\n```jsx\nfunction Card({title = \"Default title\"}) {\n  return <div>{title}</div>\n}\n```\n\n## 3. Relying on PropTypes\n\nPropTypes was React's initial solution for typing. However, TypeScript has become the industry standard for handling types in JavaScript.\n\n**❌ Using PropTypes:**\n```jsx\nimport { PropTypes } from \"prop-types\";\n\nfunction Card(props) {\n  return <div>{props.title}</div>\n}\n\nCard.propTypes = {\n  title: PropTypes.string.isRequired\n};\n```\n\n**✅ Using TypeScript:**\n```tsx\ninterface CardProps {\n  title: string;\n}\n\nfunction Card({title}: CardProps) {\n  return <div>{title}</div>\n}\n```\n\n## 4. Writing Class Components\n\nClass components were the primary way to create stateful components in React. With the introduction of Hooks, functional components have become the preferred choice.\n\n**❌ Class component:**\n```jsx\nclass Card extends React.Component {\n  render() {\n    return <div>{this.props.title}</div>\n  }\n}\n```\n\n**✅ Functional component with Hooks:**\n```jsx\nfunction Card({title}) {\n  const [count, setCount] = useState(0);\n  return <div>{title}</div>\n}\n```\n\n## 5. Unnecessarily Importing React\n\nSince React 17, it's no longer necessary to import React in every file that uses JSX.\n\n**❌ Before React 17:**\n```jsx\nimport React from 'react';\n\nfunction Card() {\n  return <div>Card</div>\n}\n```\n\n**✅ Now:**\n```jsx\nfunction Card() {\n  return <div>Card</div>\n}\n\n// Only import React when using hooks or other specific features\nimport { useState } from 'react';\n```\n\n## Conclusion\n\nReact's evolution has brought better practices and more efficient tools. Staying updated with these practices will not only improve our code quality but also allow us to take full advantage of React's modern capabilities.\n\nRemember that these \"mistakes\" aren't really critical errors - the code will still work. However, adopting new practices will help us write more maintainable, efficient code that aligns with current React community standards.\n\nThe key is not to feel overwhelmed by these changes but to gradually incorporate them into our development workflow. As our applications grow in complexity, these modern practices will prove increasingly valuable in maintaining clean, performant React applications.","src/content/blog/common-react-mistakes.mdx","a2f3e499f4a7fdf9","react-performance-composition",{id:103,data:105,body:110,filePath:111,digest:112,deferredRender:21},{title:106,description:107,pubDate:108,heroImage:109},"React Performance Optimization Through Composition","Learn how to improve React app performance using composition patterns instead of complex optimizations",["Date","2025-01-23T23:00:00.000Z"],"/post-react.webp","When dealing with performance issues in React, developers often reach for complex solutions like `useMemo`, `useCallback`, or `React.memo`. However, simple composition patterns can often solve performance problems more elegantly.\n\n## The Problem: Unnecessary Re-renders\n\nConsider this common scenario:\n\n```jsx\nconst App = () => {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  \n  return (\n    <div>\n      <ExpensiveComponent />\n      <ComplexDataGrid />\n      <button onClick={() => setIsModalOpen(true)}>\n        Open Modal\n      </button>\n      {isModalOpen && <Modal onClose={() => setIsModalOpen(false)} />}\n    </div>\n  );\n}\n```\n\nEvery time the modal opens or closes, both `ExpensiveComponent` and `ComplexDataGrid` will re-render unnecessarily. This happens because state changes trigger re-renders for the component and all its children.\n\n## Solution 1: Moving State Down\n\nInstead of managing modal state in the parent, we can isolate it in its own component:\n\n```jsx\n// ✅ Good: Modal state is isolated\nconst ModalButton = () => {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return (\n    <>\n      <button onClick={() => setIsOpen(true)}>\n        Open Modal\n      </button>\n      {isOpen && <Modal onClose={() => setIsOpen(false)} />}\n    </>\n  );\n}\n\n// Now the expensive components won't re-render when modal state changes\nconst App = () => {\n  return (\n    <div>\n      <ExpensiveComponent />\n      <ComplexDataGrid />\n      <ModalButton />\n    </div>\n  );\n}\n```\n\n## Solution 2: Children as Props\n\nSometimes you need to share data between components but don't want to trigger unnecessary re-renders. The `children` prop is perfect for this:\n\n```jsx\nconst Layout = ({ children }) => {\n  const [sidebarWidth, setSidebarWidth] = useState(200);\n  \n  return (\n    <div style={{ display: 'flex' }}>\n      <Sidebar width={sidebarWidth} onResize={setSidebarWidth} />\n      <main>\n        {children}\n      </main>\n    </div>\n  );\n}\n\n// Changes to sidebar width won't cause content to re-render\nconst App = () => {\n  return (\n    <Layout>\n      <ExpensiveComponent />\n      <ComplexDataGrid />\n    </Layout>\n  );\n}\n```\n\n## Solution 3: Component Splitting\n\nWhen dealing with forms, split components based on which parts need to update together:\n\n```jsx\nconst ExpensivePreview = ({ data }) => {\n  // Heavy calculations here\n  return <div>{/* Complex rendering */}</div>;\n}\n\nconst Form = () => {\n  const [formData, setFormData] = useState(initialData);\n  \n  return (\n    <div>\n      <FormInputs \n        data={formData}\n        onChange={setFormData}\n      />\n      <ExpensivePreview data={formData} />\n    </div>\n  );\n}\n\n// Only form inputs re-render on every keystroke\nconst FormInputs = ({ data, onChange }) => {\n  return (\n    <div>\n      <input \n        value={data.name}\n        onChange={e => onChange({ ...data, name: e.target.value })}\n      />\n      {/* More inputs */}\n    </div>\n  );\n}\n```\n\n## Real World Example: DataGrid with Filters\n\nHere's a practical example combining these patterns:\n\n```jsx\nconst DataGridWithFilters = () => {\n  return (\n    <div>\n      <FiltersSection />\n      <DataGrid />\n    </div>\n  );\n}\n\nconst FiltersSection = () => {\n  const [filters, setFilters] = useState(initialFilters);\n  \n  return (\n    <FilterContext.Provider value={{ filters, setFilters }}>\n      <div>\n        <QuickFilters />\n        <AdvancedFilters />\n      </div>\n    </FilterContext.Provider>\n  );\n}\n\nconst DataGrid = () => {\n  const { filters } = useFilterContext();\n  \n  return (\n    <div>\n      {/* Complex grid rendering */}\n    </div>\n  );\n}\n```\n\nThis structure ensures that:\n- Filter changes only re-render filter components\n- The grid only re-renders when filters actually change\n- No need for complex memoization\n\n## Key Benefits\n\n1. More maintainable code\n2. Better performance by default\n3. Less risk of memoization-related bugs\n4. Clearer data flow\n5. Easier testing\n\nComposition patterns often eliminate the need for complex optimization techniques while making your code more maintainable.","src/content/blog/react-performance-composition.mdx","194262b53a7b69bf","react-portals-guide",{id:113,data:115,body:119,filePath:120,digest:121,deferredRender:21},{title:116,description:117,pubDate:118,heroImage:17},"React Portals: When and Why to Use Them","A practical guide to implementing React Portals and solving common UI challenges",["Date","2024-12-02T23:00:00.000Z"],"## Creating a Basic Portal\n\nThe simplest implementation of a portal:\n\n```jsx\nimport { createPortal } from 'react-dom';\n\nconst Modal = ({ children, onClose }) => {\n  return createPortal(\n    <div className=\"modal-overlay\">\n      <div className=\"modal-content\">\n        {children}\n        <button onClick={onClose}>Close</button>\n      </div>\n    </div>,\n    document.getElementById('portal-root')\n  );\n};\n\n// Usage\nconst App = () => {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return (\n    <div>\n      <button onClick={() => setIsOpen(true)}>Open Modal</button>\n      {isOpen && (\n        <Modal onClose={() => setIsOpen(false)}>\n          <h2>Modal Content</h2>\n        </Modal>\n      )}\n    </div>\n  );\n};\n```\n\n## Implementing a Tooltip Portal\n\nTooltips often need to escape stacking contexts:\n\n```jsx\nconst Tooltip = ({ text, targetRef }) => {\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  \n  useLayoutEffect(() => {\n    if (targetRef.current) {\n      const rect = targetRef.current.getBoundingClientRect();\n      setPosition({\n        top: rect.bottom + 10,\n        left: rect.left + (rect.width / 2)\n      });\n    }\n  }, [targetRef]);\n\n  return createPortal(\n    <div \n      className=\"tooltip\"\n      style={{\n        position: 'fixed',\n        top: position.top,\n        left: position.left,\n        transform: 'translateX(-50%)'\n      }}\n    >\n      {text}\n    </div>,\n    document.body\n  );\n};\n\n// Usage\nconst Button = () => {\n  const [showTooltip, setShowTooltip] = useState(false);\n  const buttonRef = useRef();\n\n  return (\n    <>\n      <button \n        ref={buttonRef}\n        onMouseEnter={() => setShowTooltip(true)}\n        onMouseLeave={() => setShowTooltip(false)}\n      >\n        Hover me\n      </button>\n      {showTooltip && (\n        <Tooltip \n          text=\"I'm a tooltip!\" \n          targetRef={buttonRef} \n        />\n      )}\n    </>\n  );\n};\n```\n\n## Context-Aware Portals\n\nPortals that preserve React Context:\n\n```jsx\nconst ThemePortal = ({ children }) => {\n  const theme = useContext(ThemeContext);\n  \n  return createPortal(\n    <ThemeContext.Provider value={theme}>\n      {children}\n    </ThemeContext.Provider>,\n    document.body\n  );\n};\n\nconst ThemedModal = ({ onClose }) => {\n  const theme = useContext(ThemeContext);\n  \n  return (\n    <ThemePortal>\n      <div className={`modal-${theme}`}>\n        Modal content with theme\n        <button onClick={onClose}>Close</button>\n      </div>\n    </ThemePortal>\n  );\n};\n```\n\n## Select Dropdown with Portal\n\nHandling dropdowns that need to escape overflow:hidden:\n\n```jsx\nconst Select = ({ options, value, onChange }) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const buttonRef = useRef();\n  \n  const handleSelect = (option) => {\n    onChange(option);\n    setIsOpen(false);\n  };\n\n  return (\n    <>\n      <button \n        ref={buttonRef}\n        onClick={() => setIsOpen(!isOpen)}\n      >\n        {value || 'Select...'}\n      </button>\n      \n      {isOpen && (\n        <DropdownPortal targetRef={buttonRef}>\n          <ul className=\"options-list\">\n            {options.map(option => (\n              <li \n                key={option.value}\n                onClick={() => handleSelect(option)}\n              >\n                {option.label}\n              </li>\n            ))}\n          </ul>\n        </DropdownPortal>\n      )}\n    </>\n  );\n};\n\nconst DropdownPortal = ({ children, targetRef }) => {\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  \n  useLayoutEffect(() => {\n    if (targetRef.current) {\n      const rect = targetRef.current.getBoundingClientRect();\n      setPosition({\n        top: rect.bottom + 5,\n        left: rect.left,\n        width: rect.width\n      });\n    }\n  }, [targetRef]);\n\n  return createPortal(\n    <div \n      style={{\n        position: 'fixed',\n        ...position\n      }}\n    >\n      {children}\n    </div>,\n    document.body\n  );\n};\n```\n\n## Event Delegation with Portals\n\nHandling events in portaled components:\n\n```jsx\nconst ModalWithEvents = ({ onClose }) => {\n  const handleClick = (e) => {\n    // Stop event from reaching document click handler\n    e.stopPropagation();\n  };\n\n  useEffect(() => {\n    const handleDocumentClick = () => {\n      onClose();\n    };\n\n    document.addEventListener('click', handleDocumentClick);\n    return () => document.removeEventListener('click', handleDocumentClick);\n  }, [onClose]);\n\n  return createPortal(\n    <div onClick={handleClick} className=\"modal\">\n      Content that won't close when clicked\n    </div>,\n    document.body\n  );\n};\n```\n\n## Key Takeaways\n\n1. Use portals for modals, tooltips, and dropdowns\n2. Preserve React context when needed\n3. Handle event propagation carefully\n4. Use useLayoutEffect for positioning calculations\n5. Consider portal cleanup in useEffect","src/content/blog/react-portals-guide.mdx","6eaf00a7a91bcb89","rsc-error-handling",{id:122,data:124,body:128,filePath:129,digest:130,deferredRender:21},{title:125,description:126,pubDate:127,heroImage:17},"Error Handling and Retry Patterns with React Server Components","Learn how to handle errors gracefully and implement retry mechanisms in React Server Components",["Date","2025-02-16T23:00:00.000Z"],"React Server Components (RSCs) are transforming how we build web applications by enabling server-side rendering without sending large JavaScript bundles to the client. However, like any React component, RSCs can throw errors that need to be handled appropriately. Let's explore how to handle errors gracefully and implement retry mechanisms in React Server Components.\n\n## Understanding Error Boundaries\n\nError boundaries are React components that catch JavaScript errors anywhere in their child component tree. Instead of crashing your entire application, they allow you to:\n\n- Catch errors during rendering\n- Log those errors\n- Display a fallback UI\n\nHere's a basic implementation of an error boundary:\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  componentDidCatch(error, errorInfo) {\n    this.setState({ hasError: true })\n    console.error(error, errorInfo)\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong.</div>\n    }\n\n    return this.props.children\n  }\n}\n```\n\n## Using react-error-boundary\n\nFor a more robust solution, you can use the `react-error-boundary` library. Here's how to implement it in an RSC page:\n\n```jsx\n'use client'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nexport default function PageWithBoundary() {\n  return (\n    <>\n      <p>\n        This page demonstrates error handling with an explicit error boundary.\n      </p>\n\n      <ErrorBoundary fallback={<ErrorFallback />}>\n        <ErrorComponent />\n      </ErrorBoundary>\n    </>\n  )\n}\n\nfunction ErrorFallback() {\n  return (\n    <div className=\"text-red-700\">\n      There was an error with this content\n    </div>\n  )\n}\n```\n\n## Implementing Retry Mechanisms\n\nInstead of just showing an error message, we can give users the ability to retry failed operations. Here's how to implement a retry mechanism:\n\n```jsx\n'use client'\nimport { startTransition, useState } from 'react'\nimport { useRouter } from 'next/navigation'\n\nexport default function ErrorFallback({\n  error,\n  resetErrorBoundary,\n}) {\n  const router = useRouter()\n  const [isResetting, setIsResetting] = useState(false)\n\n  function retry() {\n    setIsResetting(true)\n\n    startTransition(() => {\n      router.refresh()\n      resetErrorBoundary()\n      setIsResetting(false)\n    })\n  }\n\n  return (\n    <div className=\"border border-orange-700 p-4 text-orange-700\">\n      <p className=\"m-0 mb-2 p-0\">\n        There was an error loading this component\n      </p>\n      <button\n        onClick={() => retry()}\n        disabled={isResetting}\n        className=\"button inline-flex items-center gap-4 rounded-md border bg-blue-500 px-4 py-2 text-white hover:bg-blue-600\"\n      >\n        {isResetting ? <Spinner /> : null}\n        Retry\n      </button>\n    </div>\n  )\n}\n```\n\nSome key points about this implementation:\n\n1. The ErrorFallback component must be a client component\n2. We use `router.refresh()` to retry rendering\n3. The retry operation is wrapped in `startTransition` since `router.refresh()` is a long-running operation\n4. A loading state provides visual feedback during retry\n\n## Best Practices\n\nWhen implementing error handling in RSCs:\n\n- Keep error boundaries as close as possible to potential error sources\n- Provide clear feedback to users when errors occur\n- Implement retry mechanisms where appropriate\n- Preserve user state and input during retries\n- Use loading states to indicate retry operations\n\n## Conclusion\n\nProper error handling is crucial for building robust React applications. By combining error boundaries with retry mechanisms, you can create a more resilient application that recovers gracefully from errors while maintaining a great user experience.\n\nRemember that while it might seem like we're only retrying specific components, we're actually refreshing the entire page. However, from the user's perspective, it appears as a seamless retry of just the failed component, which is exactly what we want.","src/content/blog/rsc-error-handling.mdx","2cfd146c9cb43e58","single-responsibility-principle-react",{id:131,data:133,body:137,filePath:138,digest:139,deferredRender:21},{title:134,description:135,pubDate:136,heroImage:17},"Single Responsibility Principle in React: Writing Better Components","Learn how to apply the Single Responsibility Principle to create more maintainable React components. Start your journey into SOLID principles with practical examples.",["Date","2025-02-06T23:00:00.000Z"],"The Single Responsibility Principle (SRP) is one of the fundamental principles of good software design. It's part of the SOLID principles, a set of guidelines that help us write better, more maintainable code. Today, let's explore how we can apply SRP to our React components.\n\n## What is Single Responsibility Principle?\n\nThe principle states that a module (or in our case, a component) should have only one reason to change. In other words, a component should do one thing, and do it well.\n\n## The Problem: A Common Anti-Pattern\n\nLet's look at a typical React component that's trying to do too much:\n\n```tsx\nconst ProductCard = () => {\n  const [product, setProduct] = useState<Product | null>(null);\n  const [inCart, setInCart] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    fetchProduct();\n  }, []);\n\n  const fetchProduct = async () => {\n    try {\n      const response = await fetch(\"/api/product/123\");\n      const data = await response.json();\n      setProduct(data);\n      checkIfInCart(data.id);\n    } catch (e) {\n      setError(e as Error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const checkIfInCart = async (productId: string) => {\n    const response = await fetch(`/api/cart/${productId}`);\n    const data = await response.json();\n    setInCart(data.inCart);\n  };\n\n  const addToCart = async () => {\n    try {\n      await fetch(\"/api/cart\", {\n        method: \"POST\",\n        body: JSON.stringify({ productId: product?.id }),\n      });\n      setInCart(true);\n    } catch (e) {\n      setError(e as Error);\n    }\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!product) return <div>Product not found</div>;\n\n  return (\n    <div className=\"product-card\">\n      <img src={product.image} alt={product.name} />\n      <h2>{product.name}</h2>\n      <p>{product.description}</p>\n      <div className=\"price\">${product.price}</div>\n      <button \n        onClick={addToCart}\n        disabled={inCart}\n      >\n        {inCart ? 'In Cart' : 'Add to Cart'}\n      </button>\n    </div>\n  );\n};\n```\n\nThis component is doing too many things:\n- Fetching product data\n- Managing cart state\n- Handling loading and error states\n- Rendering the product UI\n- Managing cart interactions\n\n## A Better Approach: Separation of Concerns\n\nLet's break this down into focused components and hooks:\n\n```tsx\n// Data fetching hook\nconst useProduct = (productId: string) => {\n  const [product, setProduct] = useState<Product | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    fetchProduct();\n  }, [productId]);\n\n  const fetchProduct = async () => {\n    try {\n      const response = await fetch(`/api/product/${productId}`);\n      const data = await response.json();\n      setProduct(data);\n    } catch (e) {\n      setError(e as Error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return { product, loading, error };\n};\n\n// Cart management hook\nconst useCart = (productId: string) => {\n  const [inCart, setInCart] = useState(false);\n\n  useEffect(() => {\n    checkIfInCart();\n  }, [productId]);\n\n  const checkIfInCart = async () => {\n    const response = await fetch(`/api/cart/${productId}`);\n    const data = await response.json();\n    setInCart(data.inCart);\n  };\n\n  const addToCart = async () => {\n    await fetch(\"/api/cart\", {\n      method: \"POST\",\n      body: JSON.stringify({ productId }),\n    });\n    setInCart(true);\n  };\n\n  return { inCart, addToCart };\n};\n\n// Presentation component\nconst ProductDisplay = ({\n  product,\n  inCart,\n  onAddToCart,\n}: {\n  product: Product;\n  inCart: boolean;\n  onAddToCart: () => void;\n}) => (\n  <div className=\"product-card\">\n    <img src={product.image} alt={product.name} />\n    <h2>{product.name}</h2>\n    <p>{product.description}</p>\n    <div className=\"price\">${product.price}</div>\n    <button \n      onClick={onAddToCart}\n      disabled={inCart}\n    >\n      {inCart ? 'In Cart' : 'Add to Cart'}\n    </button>\n  </div>\n);\n\n// Container component\nconst ProductCard = ({ productId }: { productId: string }) => {\n  const { product, loading, error } = useProduct(productId);\n  const { inCart, addToCart } = useCart(productId);\n\n  if (loading) return <LoadingSpinner />;\n  if (error) return <ErrorMessage error={error} />;\n  if (!product) return <NotFound message=\"Product not found\" />;\n\n  return (\n    <ProductDisplay \n      product={product} \n      inCart={inCart} \n      onAddToCart={addToCart}\n    />\n  );\n};\n```\n\n## Benefits of This Approach\n\n1. **Separation of Concerns**: Each piece has a clear, single responsibility\n2. **Reusability**: Hooks and components can be reused across the application\n3. **Testability**: Each part can be tested in isolation\n4. **Maintainability**: Changes to one aspect (like cart logic) don't affect others\n5. **Flexibility**: Easy to modify or replace individual pieces\n\n## How to Identify Violations of SRP\n\nHere's a practical tip: If you're describing your component and find yourself using \"and\", you might be violating SRP. For example:\n\n- \"This component fetches product data **and** manages cart state\"\n- \"This hook handles product loading **and** cart operations\"\n\nThese are signs that you should consider splitting your code into more focused pieces.\n\n## Conclusion\n\nThe Single Responsibility Principle is about creating components that are focused and maintainable. While it might seem like more work initially to split things up, the benefits in terms of maintainability, testability, and reusability are well worth it.\n\nIn future posts, we'll explore other SOLID principles and how they can help us write better React applications. Stay tuned!\n\nHappy coding! 🚀","src/content/blog/single-responsibility-principle-react.mdx","ddcdb97faa3bff7e","uselayouteffect-vs-useeffect",{id:140,data:142,body:146,filePath:147,digest:148,deferredRender:21},{title:143,description:144,pubDate:145,heroImage:17},"useLayoutEffect vs useEffect: Eliminating UI Flicker in React","Learn when and how to use useLayoutEffect to prevent visual glitches in your React applications",["Date","2025-01-16T23:00:00.000Z"],"When building React applications, you might encounter situations where components briefly flicker or show unwanted visual states. This often happens when measuring and updating DOM elements. Let's explore how to fix this using `useLayoutEffect`.\n\n## The Problem: UI Flicker\n\nHere's a common scenario where `useEffect` causes flickering:\n\n```jsx\nconst ResponsiveNavigation = () => {\n  const [visibleItems, setVisibleItems] = useState(links.length);\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const calculateVisibleItems = () => {\n      const container = containerRef.current;\n      const containerWidth = container.offsetWidth;\n      const itemWidth = 100; // Example fixed width\n      const newVisibleItems = Math.floor(containerWidth / itemWidth);\n      setVisibleItems(newVisibleItems);\n    };\n\n    calculateVisibleItems();\n    window.addEventListener('resize', calculateVisibleItems);\n    return () => window.removeEventListener('resize', calculateVisibleItems);\n  }, []);\n\n  return (\n    <nav ref={containerRef}>\n      {links.slice(0, visibleItems).map(link => (\n        <Link key={link.id} {...link} />\n      ))}\n      {visibleItems < links.length && <MoreButton />}\n    </nav>\n  );\n};\n```\n\nThis code will cause a flash where all links are shown before being cut down to the correct number.\n\n## The Solution: useLayoutEffect\n\nLet's fix it by replacing `useEffect` with `useLayoutEffect`:\n\n```jsx\nconst ResponsiveNavigation = () => {\n  const [visibleItems, setVisibleItems] = useState(0); // Start with 0 instead\n  const containerRef = useRef(null);\n\n  useLayoutEffect(() => {\n    const calculateVisibleItems = () => {\n      const container = containerRef.current;\n      const containerWidth = container.offsetWidth;\n      const itemWidth = 100;\n      const newVisibleItems = Math.floor(containerWidth / itemWidth);\n      setVisibleItems(newVisibleItems);\n    };\n\n    calculateVisibleItems();\n    window.addEventListener('resize', calculateVisibleItems);\n    return () => window.removeEventListener('resize', calculateVisibleItems);\n  }, []);\n\n  return (\n    <nav ref={containerRef}>\n      {links.slice(0, visibleItems).map(link => (\n        <Link key={link.id} {...link} />\n      ))}\n      {visibleItems < links.length && <MoreButton />}\n    </nav>\n  );\n};\n```\n\n## Understanding the Difference\n\nThe key differences between `useEffect` and `useLayoutEffect`:\n\n```jsx\n// useEffect: Runs asynchronously after render\nuseEffect(() => {\n  // Browser has already painted\n  // Visual changes here can cause flicker\n}, []);\n\n// useLayoutEffect: Runs synchronously before browser paint\nuseLayoutEffect(() => {\n  // Browser hasn't painted yet\n  // Visual changes here won't cause flicker\n}, []);\n```\n\n## Real World Example: Tooltip Positioning\n\nHere's a practical example of a tooltip that requires precise positioning:\n\n```jsx\nconst Tooltip = ({ text, targetRef }) => {\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  const tooltipRef = useRef(null);\n\n  useLayoutEffect(() => {\n    if (!targetRef.current || !tooltipRef.current) return;\n\n    const targetRect = targetRef.current.getBoundingClientRect();\n    const tooltipRect = tooltipRef.current.getBoundingClientRect();\n\n    setPosition({\n      top: targetRect.top - tooltipRect.height - 10,\n      left: targetRect.left + (targetRect.width - tooltipRect.width) / 2\n    });\n  }, [targetRef]);\n\n  return (\n    <div\n      ref={tooltipRef}\n      style={{\n        position: 'fixed',\n        top: position.top,\n        left: position.left\n      }}\n    >\n      {text}\n    </div>\n  );\n};\n```\n\n## Performance Considerations\n\n`useLayoutEffect` runs synchronously, which means it can block visual updates. Use it only when necessary:\n\n```jsx\n// ❌ Don't use useLayoutEffect for data fetching\nconst Component = () => {\n  useLayoutEffect(() => {\n    fetchData(); // Bad! Will block rendering\n  }, []);\n};\n\n// ✅ Use useEffect for operations that don't need DOM measurements\nconst Component = () => {\n  useEffect(() => {\n    fetchData(); // Good! Won't block rendering\n  }, []);\n};\n```\n\n## Server-Side Rendering Concerns\n\n`useLayoutEffect` doesn't work during SSR. Here's a pattern to handle this:\n\n```jsx\nconst useSafeLayoutEffect = () => {\n  const [mounted, setMounted] = useState(false);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  const Component = () => {\n    useLayoutEffect(() => {\n      if (!mounted) return;\n      // DOM measurements and updates here\n    }, [mounted]);\n\n    if (!mounted) {\n      return <Placeholder />; // Show a placeholder during SSR\n    }\n\n    return <ActualContent />;\n  };\n};\n```\n\n## Key Takeaways\n\n1. Use `useLayoutEffect` when you need to measure and update DOM elements\n2. Use `useEffect` for everything else\n3. Be careful with `useLayoutEffect` in SSR applications\n4. Consider performance implications - `useLayoutEffect` is synchronous","src/content/blog/uselayouteffect-vs-useeffect.mdx","24ea5d0f75e20440","react-rerenders-props-myth",{id:149,data:151,body:155,filePath:156,digest:157,deferredRender:21},{title:152,description:153,pubDate:154,heroImage:17},"Understanding React Re-renders: The Great Props Myth","Learn how React re-renders really work and debunk common misconceptions about props triggering re-renders",["Date","2025-01-09T23:00:00.000Z"],"One of the most common misconceptions in React is the statement: \"Components re-render when their props change.\" While this sounds logical, it's not entirely accurate. Let's explore how React re-renders actually work and debunk this myth.\n\n## The Basics: What Triggers a Re-render?\n\nThe initial source of all re-renders in React is **state changes**. When a state update occurs, React will re-render the component where the state lives AND all its nested components, regardless of their props.\n\nLet's see a simple example:\n\n```jsx\nconst Child = () => {\n  console.log(\"Child component renders\");\n  return <div>I'm a child</div>;\n}\n\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <Child />\n    </div>\n  );\n}\n```\n\nEvery time you click the button, the `Child` component will re-render even though it receives no props! You can verify this by checking the console logs.\n\n## The Props Myth in Action\n\nLet's modify our example to pass a prop that doesn't change:\n\n```jsx\nconst Child = ({ text }) => {\n  console.log(\"Child component renders\");\n  return <div>{text}</div>;\n}\n\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <Child text=\"I never change\" />\n    </div>\n  );\n}\n```\n\nThe `Child` component will still re-render on every button click, even though its `text` prop never changes. This demonstrates that prop changes alone don't determine whether a component re-renders.\n\n## When Do Props Matter?\n\nProps only matter for re-renders when a component is wrapped in `React.memo`:\n\n```jsx\nconst Child = React.memo(({ text }) => {\n  console.log(\"Child component renders\");\n  return <div>{text}</div>;\n});\n\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <Child text=\"I never change\" />\n    </div>\n  );\n}\n```\n\nNow the `Child` component will only re-render if its props change. Since we're passing a static string, it won't re-render when the parent's state changes.\n\n## Real World Example: Optimizing a Form\n\nHere's a practical example of how understanding re-renders can help optimize performance:\n\n```jsx\nconst ExpensiveComponent = () => {\n  // Imagine this component does heavy calculations\n  console.log(\"Expensive render\");\n  return <div>I'm expensive to render!</div>;\n}\n\n// ❌ Bad: ExpensiveComponent will re-render on every keystroke\nconst Form = () => {\n  const [text, setText] = useState(\"\");\n  \n  return (\n    <div>\n      <input \n        value={text}\n        onChange={(e) => setText(e.target.value)}\n      />\n      <ExpensiveComponent />\n    </div>\n  );\n}\n\n// ✅ Good: Move state to a separate component\nconst Input = () => {\n  const [text, setText] = useState(\"\");\n  \n  return (\n    <input \n      value={text}\n      onChange={(e) => setText(e.target.value)}\n    />\n  );\n}\n\nconst BetterForm = () => {\n  return (\n    <div>\n      <Input />\n      <ExpensiveComponent />\n    </div>\n  );\n}\n```\n\nIn the optimized version, typing in the input won't cause `ExpensiveComponent` to re-render because the state changes are isolated in the `Input` component.\n\n## Key Takeaways\n\n1. State changes trigger re-renders, not prop changes\n2. When a component re-renders, all its children re-render by default\n3. `React.memo` makes components check their props before re-rendering\n4. Moving state down the component tree can prevent unnecessary re-renders\n\nUnderstanding these concepts helps write more performant React applications without premature optimization.","src/content/blog/react-rerenders-props-myth.mdx","ffb99e2ecc02fef6","stoicism-life-philosophy",{id:158,data:160,body:164,filePath:165,digest:166,deferredRender:21},{title:161,description:162,pubDate:163,heroImage:17},"Stoicism as a Life Philosophy","A personal reflection on how stoicism can transform our perspective on success and happiness",["Date","2025-01-27T23:00:00.000Z"],"# Stoicism as a Life Philosophy\n\nLast year, I made **a decision that would change my life** forever: *\"Stoicism will be my life philosophy.\"*\n\n## The Pursuit of Traditional Success\n\nFor a long time, society has made us believe that our happiness and fulfillment would come from:\n\n- Having **more money**\n- Having a job with more **recognition**\n- Having a **bigger house**\n- Having an **expensive car**\n- Having the **latest smartphone**, branded clothes, etc.\n\nSince childhood, we've been taught that we must strive to have all of this. The common narrative suggests that **people will appreciate us more if we have more money, they'll admire us more if we have an expensive car, they'll respect us more if we have a high position in a company.**\n\n## The Stoic Awakening\n\nThis idea never quite convinced me. I knew people who had everything but were depressed.\n\nThanks to an algorithm, I found stoicism and, after reading Seneca, Epictetus, and Marcus Aurelius, **I learned that what I needed to \"have\" were different things.**\n\n## The True Values\n\nIf we want to live a life worth living, a life we won't regret on our deathbed, it's more important to have:\n\n- **Virtues** that guide our thoughts and actions\n- **Routines** that shape our days\n- **Aphorisms** to turn to when our inner waters are rough\n- **Mindset** that's proof against adversities and difficulties\n- **Attention** directed to the present moment\n\n## Conclusion\n\nThis is what I strive to have every day. This is what guides my life. This is **what's under my control.**\n\nAs Seneca says, we cannot put our serenity and happiness in Fortune's hands. If we lack our inner strength and serenity, then we \"have\" nothing, regardless of how many material possessions we accumulate.","src/content/blog/stoicism-life-philosophy.mdx","0cf1f1c8f7559a4c"];

export { _astro_dataLayerContent as default };
